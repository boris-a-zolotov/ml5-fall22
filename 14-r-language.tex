\subsection{Лекция 14}

% 16 раздел
\subsubsection{R-вычислимость}
\begin{remark}
    Не имеет никакого отношения к языку программирования R.
\end{remark}

\begin{definition}
    Программа — это непустая последовательность операторов $(I_0, \dots, I_l)$.
    % TODO: (стиль) грамматику операторов можно записать по-красивому.
    Оператор — либо оператор присваивания, либо условный оператор.
    Операторы присваивания: $r_i\defeq 0$, $r_i\defeq r_i+1$ и $r_i\defeq r_j$.
    Условный оператор: $r_i=r_j\Rightarrow k$
    
    Здесь $r_0, r_1, r_2, \dots$ — переменные со значениями в $\bn$
\end{definition}

% TODO: (пропущенная часть) здесь был пример программы. Из-за ошибки в коде она вычисляла не то, что надо. Поэтому я решил её не переписывать

\begin{definition}\
    \begin{enumerate}
        \item \emph{Длина программы} равна $l+1$
        \item $\text{Память}(P)$ равна наибольшему номеру переменной, входящему в P.
        \item \emph{Состояние программы} в момент $t$ при начальных данных $r_i=x_i\in \bn$ — это кортеж
            $$(r_0(t), \dots, r_m(t), k(t)),$$
            где $r_i(t)$ — содержимое регистра $r_i$ в момент $t$, а $k(t)$ — номер оператора, выполняющегося в момент $t$. Если $k(t)\ge l+1$, то считаем $k(t+1)=k(t)$
    \end{enumerate}
\end{definition}

\begin{definition}
    Пусть $P$ — программа и $n\ge 0$. Тогда $P$ вычисляет частичную функцию $\vfi_P(x_0 \ldots, x_n)$ на $\bn$, которая определяется так: при любых $\overline{x}\in\bn$ зададим значения $r_0=x_0,\dots,r_n=x_n$; $r_i=0$ при $i>n$ и запустим $P$. Если $P$ никогда не останавливается (то есть $\forall t~k(t)\le l$), то $\vfi_P(\overline{x})$ не определена. Если же она остановится в момент $t$, то $\vfi_P(\overline{x})=r_0(t)$.

    Функции такого вида называются $R$-вычислимыми.
\end{definition}

\begin{prop}\
    \begin{enumerate}
        \item $+, \cdot, \chi_<, I_k^m$ $R$-вычислимы.
        \item Суперпозиция R-вычислимых функций R-вычислима.
        \item Минимизация R-вычислимых функций R-вычислима.
    \end{enumerate}
\end{prop}

Есть вариант этого предложения для тотальных функций, есть для частичных. Оба верны.

% Тут было пояснение как определяется суперпозиция и минимизация частичных функций. Можно написать.

% 17 раздел
\subsubsection{R-вычислимость и рекурсивность}
\begin{theorem}
    Класс тотальных R-вычислимых функций совпадает с классом рекурсивных функций.
\end{theorem}

% Завернуть оставшуюся часть лекции в окружение доказательство? Тут только набросок и вспомогательные определения, само доказательство разбиралось на практиках.
\begin{definition}\
Закодируем операторы программы натуральными числами:
    \begin{itemize}
        \item $\cor{r_i\defeq 0} = \langle 0, i \rangle$
        \item $\cor{r_i\defeq r_{i+1}} = \langle 1, i \rangle $
        \item $\cor{r_i\defeq r_j} = \langle 2, i, j \rangle $
        \item $\cor{r_i=r_j\Rightarrow k} = \langle 3, i, j, k \rangle $
        \item $\cor{P} = \langle \cor{I_0}, \dots, \cor{I_l}\rangle $
    \end{itemize}
\end{definition}

\begin{definition}\
    \begin{itemize}
        \item $\text{Оп}(a)$ означает, что $a$ — код некоторого оператора.
        \item $\text{Прог}(a)$ означает, что $a$ — код некоторой программы.
        \item $\text{Пер}(i, a)$ означает, что $a$ — код некоторой программы, в которую входит $r_i$.
        \item $\text{дл}(a)$ равна длине программы $P$, если $a$ — код программы $P$; иначе 0.
        \item $\text{пам}(a)$ равна $\text{Память}(P)$, если $a$ — код программы $P$; иначе 0.
        \item $\text{сос}(a, x_0, \dots, x_n, t)$ равна коду состояния $P$ в момент $t$ при $r_i=x_i$ для $i\le n$ и $r_i=0$ для $i>n$, если $a$ — код $P$; иначе 0. % состояние определялось в начале лекции
    \end{itemize}
\end{definition}

\begin{prop}[Свойства кодирования]\
    \begin{enumerate}
        \item Коды разных операторов различны
        \item Коды разных программ различны
        \item Все описанные предикаты рекурсивны 
        \item Если $r_i$ входит в $P$, то $i<\cor{P}$
        \item Если $k$ — номер условного оператора, входящего в $P$, то $k<\cor{P}$
        \item Существует алгоритм, который по программе вычисляет её код и наоборот.
    \end{enumerate}
\end{prop}
